<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Track 1: Cloud Foundations ‚Äî Drag & Drop Check for Understanding</title>
  <style>
    :root{
      --bg:#0b1220; --panel:#101a2e; --panel2:#0f172a; --text:#e5e7eb;
      --muted:#a7b0c0; --accent:#60a5fa; --good:#34d399; --bad:#fb7185; --warn:#fbbf24;
      --card:#0b162c; --line:#23324b;
      --shadow: 0 10px 20px rgba(0,0,0,.25);
      --radius: 14px;
      --font: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
    }
    *{box-sizing:border-box}
    body{
      margin:0; font-family:var(--font); background:linear-gradient(180deg,#070b14 0%, #0b1220 40%, #070b14 100%);
      color:var(--text);
    }
    header{
      padding:20px 18px 10px;
      max-width:1200px; margin:0 auto;
    }
    h1{margin:0 0 6px; font-size:20px; font-weight:750; letter-spacing:.2px}
    .sub{margin:0; color:var(--muted); font-size:14px}
    .wrap{
      max-width:1200px; margin:0 auto; padding:12px 18px 22px;
      display:grid; grid-template-columns: 1.2fr .8fr; gap:14px;
    }
    @media (max-width: 980px){
      .wrap{grid-template-columns: 1fr; }
    }
    .card{
      background:linear-gradient(180deg,var(--panel) 0%, var(--panel2) 100%);
      border:1px solid rgba(255,255,255,.06);
      border-radius:var(--radius);
      box-shadow:var(--shadow);
      overflow:hidden;
    }
    .cardHead{
      padding:14px 14px 10px;
      border-bottom:1px solid rgba(255,255,255,.06);
      display:flex; align-items:flex-start; justify-content:space-between; gap:10px;
    }
    .cardHead h2{margin:0; font-size:16px; font-weight:750}
    .pill{
      font-size:12px; color:var(--muted);
      border:1px solid rgba(255,255,255,.10);
      padding:6px 10px; border-radius:999px;
      white-space:nowrap;
    }
    .content{padding:14px}
    .controls{
      display:flex; flex-wrap:wrap; gap:10px; align-items:center; justify-content:space-between;
      margin-bottom:12px;
    }
    .btnRow{display:flex; flex-wrap:wrap; gap:10px}
    button{
      background:rgba(96,165,250,.15);
      border:1px solid rgba(96,165,250,.35);
      color:var(--text);
      padding:10px 12px;
      border-radius:12px;
      font-weight:700;
      cursor:pointer;
    }
    button:hover{border-color: rgba(96,165,250,.6)}
    button.secondary{
      background:rgba(255,255,255,.06);
      border-color: rgba(255,255,255,.12);
      font-weight:650;
    }
    button.danger{
      background:rgba(251,113,133,.12);
      border-color: rgba(251,113,133,.4);
    }
    .hint{
      color:var(--muted); font-size:13px; line-height:1.35;
    }
    .grid{
      display:grid; grid-template-columns: 1fr; gap:10px;
    }
    .q{
      padding:12px;
      border:1px solid rgba(255,255,255,.08);
      background:rgba(11,22,44,.55);
      border-radius:14px;
      line-height:1.55;
      font-size:15px;
    }
    .blank{
      display:inline-flex;
      align-items:center;
      justify-content:center;
      min-width:120px;
      padding:6px 10px;
      margin:0 4px;
      border-radius:12px;
      border:1px dashed rgba(255,255,255,.22);
      background:rgba(255,255,255,.04);
      vertical-align:middle;
      position:relative;
      gap:8px;
      user-select:none;
    }
    .blank.filled{
      border-style:solid;
      border-color: rgba(96,165,250,.45);
      background:rgba(96,165,250,.10);
    }
    .blank.correct{
      border-color: rgba(52,211,153,.55);
      background:rgba(52,211,153,.12);
    }
    .blank.incorrect{
      border-color: rgba(251,113,133,.55);
      background:rgba(251,113,133,.10);
    }
    .blank small{
      color:var(--muted);
      position:absolute; top:-9px; left:10px;
      background:rgba(16,26,46,.95);
      padding:0 6px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.08);
      font-size:11px;
    }
    .token{
      display:inline-flex;
      align-items:center;
      justify-content:center;
      padding:8px 10px;
      border-radius:12px;
      background:rgba(255,255,255,.06);
      border:1px solid rgba(255,255,255,.14);
      cursor:grab;
      font-weight:750;
      user-select:none;
      box-shadow: 0 8px 16px rgba(0,0,0,.22);
    }
    .token:active{cursor:grabbing}
    .token.used{
      opacity:.45;
      text-decoration: line-through;
      cursor:not-allowed;
    }
    .bank{
      min-height:110px;
      padding:12px;
      border-radius:14px;
      border:1px solid rgba(255,255,255,.10);
      background:rgba(11,22,44,.45);
      display:flex; flex-wrap:wrap; gap:8px;
    }
    .bank.dragOver{outline:2px solid rgba(96,165,250,.5)}
    .scoreBox{
      display:flex; align-items:center; justify-content:space-between; gap:10px;
      padding:12px;
      border-radius:14px;
      border:1px solid rgba(255,255,255,.10);
      background:rgba(11,22,44,.45);
      margin-bottom:12px;
    }
    .scoreText{font-weight:800}
    .status{color:var(--muted); font-size:13px}
    .legend{
      display:flex; flex-wrap:wrap; gap:10px; align-items:center;
      color:var(--muted); font-size:12px; margin-top:8px;
    }
    .dot{width:10px; height:10px; border-radius:999px; display:inline-block; margin-right:6px}
    .dot.good{background:var(--good)}
    .dot.bad{background:var(--bad)}
    .dot.neutral{background:rgba(255,255,255,.22)}
    .sideList{
      display:grid; gap:10px;
    }
    .fix{
      padding:12px;
      border-radius:14px;
      border:1px solid rgba(255,255,255,.08);
      background:rgba(11,22,44,.55);
    }
    .fix h3{margin:0 0 6px; font-size:14px}
    .fix p{margin:6px 0; color:var(--muted); font-size:13px; line-height:1.35}
    .fix .row{
      display:flex; flex-wrap:wrap; gap:10px; align-items:center; margin-top:8px;
      font-size:13px;
    }
    .tag{
      padding:6px 10px; border-radius:999px;
      border:1px solid rgba(255,255,255,.12);
      background:rgba(255,255,255,.05);
      font-weight:700;
    }
    .tag.good{border-color: rgba(52,211,153,.45); background:rgba(52,211,153,.10)}
    .tag.bad{border-color: rgba(251,113,133,.45); background:rgba(251,113,133,.10)}
    .tapHint{
      margin-top:10px;
      padding:10px 12px;
      border-radius:14px;
      border:1px solid rgba(255,255,255,.10);
      background:rgba(255,255,255,.04);
      color:var(--muted);
      font-size:13px;
      line-height:1.35;
    }
    select{
      background:rgba(255,255,255,.06);
      border:1px solid rgba(255,255,255,.14);
      border-radius:12px;
      padding:10px 10px;
      color:var(--text);
      font-weight:700;
    }
    option{background:#0b1220}
    footer{
      max-width:1200px; margin:0 auto; padding:0 18px 22px;
      color:var(--muted); font-size:12px;
    }
    a{color:var(--accent)}
  </style>
</head>
<body>
<header>
  <h1>Track 1: Cloud Foundations ‚Äî Drag & Drop Check for Understanding</h1>
  <p class="sub">Drag terms from the word bank into the blanks. Then click <b>Submit</b> to see your score and corrections.</p>
</header>

<div class="wrap">
  <!-- LEFT: QUIZ -->
  <section class="card" aria-label="Quiz">
    <div class="cardHead">
      <h2>Quiz</h2>
      <div class="pill" id="progressPill">0 / 18 filled</div>
    </div>
    <div class="content">
      <div class="controls">
        <div class="btnRow">
          <button id="submitBtn">Submit</button>
          <button class="secondary" id="resetBtn">Reset</button>
          <button class="secondary" id="shuffleBtn">Shuffle Word Bank</button>
        </div>
        <div class="hint">
          Tip: You can drag a term back to the bank to remove it.<br>
          Mobile-friendly: tap a term, then tap a blank.
        </div>
      </div>

      <div class="scoreBox" role="status" aria-live="polite">
        <div>
          <div class="scoreText" id="scoreText">Score: ‚Äî</div>
          <div class="status" id="scoreStatus">Fill the blanks, then submit.</div>
        </div>
        <div>
          <label for="tapSelect" class="status" style="display:block;margin-bottom:6px;">Tap-to-place (optional)</label>
          <select id="tapSelect">
            <option value="">Tap a term to select‚Ä¶</option>
          </select>
        </div>
      </div>

      <div class="legend" aria-hidden="true">
        <span><span class="dot neutral"></span>Blank</span>
        <span><span class="dot good"></span>Correct</span>
        <span><span class="dot bad"></span>Incorrect</span>
      </div>

      <div class="tapHint">
        <b>Phone / tablet tip:</b> If dragging is annoying, use the dropdown on the right:
        select a term ‚Üí tap a blank to place it.
      </div>

      <h3 style="margin:14px 0 10px;font-size:14px;color:var(--muted);">Word Bank</h3>
      <div id="bank" class="bank" aria-label="Word bank (drag terms from here)" tabindex="0"></div>

      <h3 style="margin:16px 0 10px;font-size:14px;color:var(--muted);">Sentences</h3>
      <div id="questions" class="grid"></div>
    </div>
  </section>

  <!-- RIGHT: FEEDBACK -->
  <aside class="card" aria-label="Corrections">
    <div class="cardHead">
      <h2>Corrections</h2>
      <div class="pill" id="missedPill">Missed: ‚Äî</div>
    </div>
    <div class="content">
      <div class="hint" style="margin-bottom:10px;">
        After you submit, only the blanks you missed will show here, with the full sentence for context.
      </div>
      <div id="corrections" class="sideList"></div>
    </div>
  </aside>
</div>

<footer>
  <div>Built from your ‚ÄúTrack 1: Cloud Foundations ‚Äî Check for Understanding‚Äù worksheet.</div>
</footer>

<script>
  // ====== DATA (from the PDF) ======
  const WORD_BANK = [
    "cloud","client","server","internet","data centers","networks","process","redundancy",
    "uptime","downtime","rent","scaling","usage-based","bandwidth","latency",
    "web","software","demand","hardware"
  ];

  // Each question is a sentence template with placeholder tokens like {b1}, {b2}, etc.
  // Answers map each blank id -> correct word.
  // Note: total blanks = 18 (matches the worksheet lines with blanks).
  const QUIZ = [
    {
      id: "q1",
      text: "The {b1} is someone else‚Äôs computers that you use over the internet.",
      answers: { b1: "cloud" }
    },
    {
      id: "q2",
      text: "Your device is the {b2}. The remote computer is the {b3}. The {b4} connects them.",
      answers: { b2: "client", b3: "server", b4: "internet" }
    },
    {
      id: "q3",
      text: "Cloud systems use many computers in {b5} working together.",
      answers: { b5: "data centers" }
    },
    {
      id: "q4",
      text: "Computers communicate through {b6}. Some computers store data, while others {b7} data.",
      answers: { b6: "networks", b7: "process" }
    },
    {
      id: "q5",
      text: "{b8} allows systems to stay online even if one computer fails.",
      answers: { b8: "redundancy" }
    },
    {
      id: "q6",
      text: "{b9} means a system is available. {b10} means it is not.",
      answers: { b9: "uptime", b10: "downtime" }
    },
    {
      id: "q7",
      text: "The cloud allows companies to {b11} computing power instead of owning hardware.",
      answers: { b11: "rent" }
    },
    {
      id: "q8",
      text: "{b12} up means adding resources when demand increases.",
      answers: { b12: "scaling" }
    },
    {
      id: "q9",
      text: "{b13} down means removing resources when demand decreases.",
      answers: { b13: "scaling" }
    },
    {
      id: "q10",
      text: "Cloud systems often use {b14} pricing instead of fixed costs.",
      answers: { b14: "usage-based" }
    },
    {
      id: "q11",
      text: "{b15} refers to how much data can move at once.",
      answers: { b15: "bandwidth" }
    },
    {
      id: "q12",
      text: "{b16} refers to delay in data transfer.",
      answers: { b16: "latency" }
    },
    {
      id: "q13",
      text: "{b17} development, {b18} development, cybersecurity, and data & AI all rely on cloud systems.",
      answers: { b17: "web", b18: "software" }
    },
    {
      id: "q14",
      text: "The cloud exists because {b19} changes faster than {b20}.",
      answers: { b19: "demand", b20: "hardware" }
    }
  ];

  // Flatten blank ids and build an ordered list for progress/scoring.
  const BLANKS = (() => {
    const out = [];
    for (const q of QUIZ){
      for (const [blankId, correct] of Object.entries(q.answers)){
        out.push({ qid: q.id, blankId, correct, questionText: q.text });
      }
    }
    return out;
  })();

  // ====== STATE ======
  const state = {
    // blankId -> chosen word
    filled: {},
    // word -> count used (for handling "scaling" used twice)
    usedCount: {},
    submitted: false,
    selectedTapWord: ""
  };

  // ====== HELPERS ======
  function shuffle(arr){
    const a = arr.slice();
    for (let i=a.length-1; i>0; i--){
      const j = Math.floor(Math.random()*(i+1));
      [a[i], a[j]] = [a[j], a[i]];
    }
    return a;
  }

  function escapeHtml(s){
    return s.replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#039;'}[m]));
  }

  function renderTextWithBlanks(q){
    // Replace {bX} with a blank span.
    let html = escapeHtml(q.text);
    html = html.replace(/\{(b\d+)\}/g, (_, bid) => {
      const labelNum = bid.replace("b","");
      return `<span class="blank" data-blank="${bid}" role="button" tabindex="0" aria-label="Blank ${labelNum}"><small>#${labelNum}</small><span class="blankVal">${state.filled[bid] ? escapeHtml(state.filled[bid]) : ""}</span></span>`;
    });
    return html;
  }

  function updateProgress(){
    const total = BLANKS.length;
    const filledCount = Object.keys(state.filled).filter(k => state.filled[k]).length;
    document.getElementById("progressPill").textContent = `${filledCount} / ${total} filled`;
  }

  function updateTapDropdown(){
    const sel = document.getElementById("tapSelect");
    // rebuild options to reflect current bank order, but keep selection if possible
    const current = state.selectedTapWord;
    sel.innerHTML = `<option value="">Tap a term to select‚Ä¶</option>` +
      WORD_BANK.map(w => `<option value="${escapeHtml(w)}">${escapeHtml(w)}</option>`).join("");
    sel.value = current || "";
  }

  function canUseWord(word){
    // Word bank includes each term once, except "scaling" appears once in bank but is used twice in answers.
    // For better UX, we allow "scaling" to be placed up to 2 times.
    // Everything else: max 1.
    const max = (word === "scaling") ? 2 : 1;
    return (state.usedCount[word] || 0) < max;
  }

  function markWordUsed(word, delta){
    state.usedCount[word] = (state.usedCount[word] || 0) + delta;
    if (state.usedCount[word] <= 0) delete state.usedCount[word];
  }

  function setBlank(blankId, word){
    // remove existing
    if (state.filled[blankId]){
      const old = state.filled[blankId];
      state.filled[blankId] = "";
      markWordUsed(old, -1);
    }
    if (!word) return;

    if (!canUseWord(word)) return;

    state.filled[blankId] = word;
    markWordUsed(word, +1);
  }

  function clearBlank(blankId){
    if (state.filled[blankId]){
      const old = state.filled[blankId];
      state.filled[blankId] = "";
      markWordUsed(old, -1);
    }
  }

  function renderBank(bankWords){
    const bank = document.getElementById("bank");
    bank.innerHTML = "";
    bankWords.forEach(word => {
      const used = !canUseWord(word) ? "used" : "";
      const el = document.createElement("div");
      el.className = `token ${used}`;
      el.textContent = word;
      el.setAttribute("draggable", used ? "false" : "true");
      el.dataset.word = word;

      el.addEventListener("dragstart", e => {
        if (!canUseWord(word)) return e.preventDefault();
        e.dataTransfer.setData("text/plain", word);
      });

      // tap-to-select convenience
      el.addEventListener("click", () => {
        state.selectedTapWord = word;
        document.getElementById("tapSelect").value = word;
      });

      bank.appendChild(el);
    });

    bank.addEventListener("dragover", e => {
      e.preventDefault();
      bank.classList.add("dragOver");
    });
    bank.addEventListener("dragleave", () => bank.classList.remove("dragOver"));
    bank.addEventListener("drop", e => {
      e.preventDefault();
      bank.classList.remove("dragOver");
      // Dropping onto bank is handled by blank-drag logic (we clear the blank when dragged away)
      // Nothing needed here.
    });
  }

  function renderQuestions(){
    const container = document.getElementById("questions");
    container.innerHTML = "";
    QUIZ.forEach(q => {
      const div = document.createElement("div");
      div.className = "q";
      div.dataset.qid = q.id;
      div.innerHTML = renderTextWithBlanks(q);
      container.appendChild(div);
    });

    // Attach DnD + tap handlers to blanks
    container.querySelectorAll(".blank").forEach(blank => {
      const blankId = blank.dataset.blank;

      blank.addEventListener("dragover", e => {
        e.preventDefault();
        blank.classList.add("dragOver");
      });
      blank.addEventListener("dragleave", () => blank.classList.remove("dragOver"));
      blank.addEventListener("drop", e => {
        e.preventDefault();
        blank.classList.remove("dragOver");
        const word = e.dataTransfer.getData("text/plain");
        if (!word) return;
        setBlank(blankId, word);
        rerenderAll();
      });

      // Tap-to-place: if dropdown has a value, place it
      const tapPlace = () => {
        const chosen = document.getElementById("tapSelect").value || state.selectedTapWord;
        if (!chosen) return;
        // allow scaling twice, others once
        if (!canUseWord(chosen) && state.filled[blankId] !== chosen) return;

        setBlank(blankId, chosen);
        // keep selection (nice for placing scaling twice)
        rerenderAll();
      };

      blank.addEventListener("click", tapPlace);
      blank.addEventListener("keydown", (e) => {
        if (e.key === "Enter" || e.key === " ") {
          e.preventDefault();
          tapPlace();
        }
      });

      // Allow clearing by double-click (desktop) for convenience
      blank.addEventListener("dblclick", () => {
        clearBlank(blankId);
        rerenderAll();
      });
    });

    // Allow dragging filled token out by making filled text draggable via blank itself:
    container.querySelectorAll(".blank").forEach(blank => {
      blank.setAttribute("draggable", "true");
      blank.addEventListener("dragstart", e => {
        const bid = blank.dataset.blank;
        const word = state.filled[bid];
        if (!word) return e.preventDefault();
        e.dataTransfer.setData("text/plain", word);
        // clear immediately so dropping back to bank "removes"
        clearBlank(bid);
        rerenderAll();
      });
    });
  }

  function grade(){
    const results = [];
    let correctCount = 0;

    for (const b of BLANKS){
      const your = (state.filled[b.blankId] || "").trim().toLowerCase();
      const correct = b.correct.toLowerCase();
      const ok = your === correct;
      if (ok) correctCount++;
      results.push({ ...b, your: state.filled[b.blankId] || "", ok });
    }
    return { results, correctCount, total: BLANKS.length };
  }

  function renderCorrections(gradeObj){
    const panel = document.getElementById("corrections");
    const missed = gradeObj.results.filter(r => !r.ok);

    document.getElementById("missedPill").textContent = `Missed: ${missed.length}`;

    panel.innerHTML = "";
    if (!state.submitted){
      panel.innerHTML = `<div class="hint">Submit your answers to see corrections here.</div>`;
      return;
    }
    if (missed.length === 0){
      panel.innerHTML = `
        <div class="fix">
          <h3>Perfect score üéâ</h3>
          <p>You got every blank correct.</p>
        </div>`;
      return;
    }

    // Build sentence context: replace only that blank with a highlighted marker.
    missed.forEach(r => {
      const ctx = r.questionText.replace(new RegExp("\\{"+r.blankId+"\\}","g"), "_____");
      const div = document.createElement("div");
      div.className = "fix";
      div.innerHTML = `
        <h3>Blank ${r.blankId.replace("b","")}</h3>
        <p><b>Sentence:</b> ${escapeHtml(ctx)}</p>
        <div class="row">
          <span class="tag bad">Your answer: ${escapeHtml(r.your || "‚Äî")}</span>
          <span class="tag good">Correct: ${escapeHtml(r.correct)}</span>
        </div>
      `;
      panel.appendChild(div);
    });
  }

  function paintAfterSubmit(gradeObj){
    // Add correct/incorrect classes to blanks
    document.querySelectorAll(".blank").forEach(el => {
      const bid = el.dataset.blank;
      const found = gradeObj.results.find(r => r.blankId === bid);
      el.classList.remove("correct","incorrect");
      if (!found) return;
      if (found.ok) el.classList.add("correct");
      else el.classList.add("incorrect");
    });
  }

  function rerenderAll(){
    // bank words display: optionally show used style
    const currentOrder = state.bankOrder || WORD_BANK.slice();
    renderBank(currentOrder);
    renderQuestions();
    updateProgress();
  }

  // ====== INIT ======
  function init(){
    state.filled = {};
    state.usedCount = {};
    state.submitted = false;
    state.bankOrder = shuffle(WORD_BANK);

    document.getElementById("scoreText").textContent = "Score: ‚Äî";
    document.getElementById("scoreStatus").textContent = "Fill the blanks, then submit.";
    document.getElementById("missedPill").textContent = "Missed: ‚Äî";

    updateTapDropdown();
    rerenderAll();
    renderCorrections({results:[], correctCount:0, total:BLANKS.length});
  }

  // ====== BUTTONS ======
  document.getElementById("submitBtn").addEventListener("click", () => {
    const g = grade();
    state.submitted = true;

    document.getElementById("scoreText").textContent = `Score: ${g.correctCount} / ${g.total}`;
    const pct = Math.round((g.correctCount / g.total) * 100);
    document.getElementById("scoreStatus").textContent =
      (pct === 100) ? "Perfect! Nice work." :
      (pct >= 80) ? "Good job. Review the missed ones on the right." :
      "Keep going. Check the corrections on the right, then try again.";

    renderCorrections(g);
    paintAfterSubmit(g);
  });

  document.getElementById("resetBtn").addEventListener("click", () => {
    init();
  });

  document.getElementById("shuffleBtn").addEventListener("click", () => {
    state.bankOrder = shuffle(WORD_BANK);
    rerenderAll();
  });

  document.getElementById("tapSelect").addEventListener("change", (e) => {
    state.selectedTapWord = e.target.value;
  });

  init();
</script>
</body>
</html>

