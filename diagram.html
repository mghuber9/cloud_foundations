<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Cloud Diagram Drag & Drop</title>
  <style>
    :root{
      --panel-bg:#ffffff;
      --border:#d0d0d0;
      --good:#1f8a3b;
      --bad:#c62828;
      --ink:#222;
    }
    body{
      margin:0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      color:var(--ink);
      background:#f6f6f6;
    }
    header{
      padding:14px 18px;
      background:#fff;
      border-bottom:1px solid var(--border);
    }
    header h1{
      margin:0;
      font-size:18px;
      font-weight:700;
    }
    header .sub{
      margin-top:6px;
      font-size:13px;
      color:#555;
      line-height:1.35;
    }
    .wrap{
      display:grid;
      grid-template-columns: 360px 1fr;
      gap:14px;
      padding:14px;
      align-items:start;
    }
    @media (max-width: 980px){
      .wrap{ grid-template-columns: 1fr; }
    }

    .panel{
      background:var(--panel-bg);
      border:1px solid var(--border);
      border-radius:10px;
      padding:12px;
      box-shadow: 0 1px 2px rgba(0,0,0,.04);
    }
    .panel h2{
      margin:0 0 10px 0;
      font-size:15px;
    }

    /* Word bank */
    #bank{
      display:flex;
      flex-wrap:wrap;
      gap:8px;
      min-height:90px;
      padding:10px;
      border:1px dashed #cfcfcf;
      border-radius:10px;
      background:#fafafa;
    }
    .word{
      user-select:none;
      cursor:grab;
      background:#fff;
      border:1px solid #cfcfcf;
      border-radius:999px;
      padding:7px 10px;
      font-size:13px;
      box-shadow: 0 1px 2px rgba(0,0,0,.06);
      white-space:nowrap;
    }
    .word:active{ cursor:grabbing; }
    .word.dragging{ opacity:.55; }

    .btnrow{
      display:flex;
      gap:8px;
      flex-wrap:wrap;
      margin-top:12px;
    }
    button{
      border:1px solid var(--border);
      background:#fff;
      padding:9px 12px;
      border-radius:10px;
      cursor:pointer;
      font-weight:600;
      font-size:14px;
    }
    button.primary{
      background:#111;
      color:#fff;
      border-color:#111;
    }
    button:disabled{ opacity:.6; cursor:not-allowed; }

    .score{
      margin-top:10px;
      font-size:14px;
      line-height:1.35;
    }

    /* Diagram */
    .stage{
      background:var(--panel-bg);
      border:1px solid var(--border);
      border-radius:10px;
      padding:12px;
      box-shadow: 0 1px 2px rgba(0,0,0,.04);
    }

    .diagram{
      position:relative;
      width:100%;
      max-width: 1100px; /* keeps it manageable on large screens */
      margin:0 auto;
    }
    .diagram img{
      width:100%;
      height:auto;
      display:block;
      border-radius:8px;
    }

    .dropzone{
      position:absolute;
      border-radius:8px;
      display:flex;
      align-items:center;
      justify-content:center;
      text-align:center;
      padding:4px;
      box-sizing:border-box;
      overflow:hidden;

      /* invisible by default; outline can be toggled */
      outline: 2px solid transparent;
      background: rgba(255,255,255,0.0);
    }
    .dropzone.show-outline{
      outline:2px dashed rgba(30,144,255,.8);
      background: rgba(255,255,255,0.12);
    }
    .dropzone.filled{
      background: rgba(255,255,255,0.45);
      outline:2px solid rgba(0,0,0,0.10);
    }
    .dropzone.good{
      outline: 3px solid rgba(31,138,59,.85);
      background: rgba(31,138,59,.12);
    }
    .dropzone.bad{
      outline: 3px solid rgba(198,40,40,.85);
      background: rgba(198,40,40,.10);
    }
    .dz-text{
      font-weight:700;
      font-size: clamp(10px, 1.25vw, 15px);
      line-height:1.05;
      text-shadow: 0 1px 0 rgba(255,255,255,.7);
      padding:2px 4px;
    }
    .hint{
      margin-top:10px;
      font-size:12px;
      color:#666;
      line-height:1.35;
    }
    .small{
      font-size:12px;
      color:#666;
    }
    .legend{
      margin-top:8px;
      font-size:12px;
      color:#666;
    }
    .legend span{
      display:inline-block;
      padding:2px 8px;
      border-radius:999px;
      margin-right:6px;
      border:1px solid #ddd;
      background:#fff;
    }
  </style>
</head>

<body>
<header>
  <h1>Cloud Diagram – Drag & Drop</h1>
  <div class="sub">
    Drag terms from the word bank into the blanks. Click a filled blank to send that term back to the bank.<br/>
    <b>Clients:</b> any Client 1–6 can go in any client blank. <b>Data Center C</b> must be in its specific spot.
  </div>
</header>

<div class="wrap">
  <aside class="panel">
    <h2>Word Bank (scrambled)</h2>
    <div id="bank" aria-label="Word bank"></div>

    <div class="btnrow">
      <button class="primary" id="submitBtn">Submit</button>
      <button id="resetBtn">Reset</button>
      <button id="outlineBtn" type="button">Toggle Box Outlines</button>
    </div>

    <div class="score" id="scoreBox"></div>

    <div class="legend">
      <span>✅ Correct</span>
      <span>❌ Incorrect</span>
      <span class="small">(Not checked until Submit)</span>
    </div>

    <div class="hint">
      <b>Teacher tip:</b> If any drop area feels slightly off, tell me which label is misaligned and I’ll adjust the coordinates.
    </div>
  </aside>

  <main class="stage">
    <div class="diagram" id="diagram">
      <!-- Put your blank image next to this HTML file named diagram.png -->
      <img src="diagram.png" alt="Blank cloud diagram with empty labels"/>

      <!-- Dropzones (positioned with percentages) -->
      <!-- Clients -->
      <div class="dropzone" data-zone="client1" style="left:4.52%; top:4.23%; width:14.37%; height:6.57%;"></div>
      <div class="dropzone" data-zone="client2" style="left:4.52%; top:18.31%; width:14.37%; height:6.57%;"></div>
      <div class="dropzone" data-zone="client3" style="left:4.52%; top:32.39%; width:14.37%; height:6.57%;"></div>
      <div class="dropzone" data-zone="client4" style="left:4.52%; top:46.48%; width:14.37%; height:6.57%;"></div>
      <div class="dropzone" data-zone="client5" style="left:4.52%; top:60.56%; width:14.37%; height:6.57%;"></div>
      <div class="dropzone" data-zone="client6" style="left:4.52%; top:74.65%; width:14.37%; height:6.57%;"></div>

      <!-- Bandwidth labels (kept specific to the original diagram) -->
      <div class="dropzone" data-zone="bw1" style="left:20.22%; top:14.08%; width:18.09%; height:5.63%;"></div>
      <div class="dropzone" data-zone="bw2" style="left:16.50%; top:25.82%; width:20.76%; height:7.04%;"></div>
      <div class="dropzone" data-zone="bw3" style="left:13.84%; top:38.50%; width:26.61%; height:7.04%;"></div>
      <div class="dropzone" data-zone="bw4" style="left:16.23%; top:52.11%; width:20.76%; height:7.04%;"></div>
      <div class="dropzone" data-zone="bw5" style="left:13.30%; top:64.79%; width:26.61%; height:7.04%;"></div>
      <div class="dropzone" data-zone="bw6" style="left:15.97%; top:78.40%; width:20.76%; height:7.04%;"></div>

      <!-- Center cloud label -->
      <div class="dropzone" data-zone="internet" style="left:38.85%; top:38.50%; width:18.09%; height:11.27%;"></div>

      <!-- Data centers / networks -->
      <div class="dropzone" data-zone="dcA" style="left:44.17%; top:3.29%; width:19.16%; height:6.57%;"></div>
      <div class="dropzone" data-zone="dcB" style="left:62.80%; top:6.10%; width:17.56%; height:6.57%;"></div>
      <div class="dropzone" data-zone="redundant" style="left:50.03%; top:22.54%; width:18.09%; height:8.45%;"></div>

      <div class="dropzone" data-zone="dcC" style="left:60.14%; top:38.97%; width:19.16%; height:6.57%;"></div>

      <div class="dropzone" data-zone="dcE" style="left:43.64%; top:59.15%; width:19.16%; height:6.57%;"></div>
      <div class="dropzone" data-zone="internal" style="left:54.28%; top:66.20%; width:17.56%; height:6.57%;"></div>

      <div class="dropzone" data-zone="dcD" style="left:61.20%; top:67.61%; width:19.16%; height:6.57%;"></div>
      <div class="dropzone" data-zone="farther" style="left:52.69%; top:80.75%; width:17.56%; height:5.63%;"></div>

      <!-- Inside Data Center E boxes -->
      <div class="dropzone" data-zone="storage" style="left:37.25%; top:71.36%; width:13.84%; height:7.98%;"></div>
      <div class="dropzone" data-zone="processing" style="left:37.25%; top:83.10%; width:13.84%; height:7.98%;"></div>

      <!-- The Cloud -->
      <div class="dropzone" data-zone="cloud" style="left:85.15%; top:11.27%; width:13.30%; height:11.27%;"></div>
    </div>

    <div class="hint">
      If the diagram doesn’t load, confirm the image filename is exactly <b>diagram.png</b> and it’s in the same folder as this HTML file.
    </div>
  </main>
</div>

<script>
  // ---------------------------
  // 1) Words (bank)
  // ---------------------------
  const WORDS = [
    "Client 1","Client 2","Client 3","Client 4","Client 5","Client 6",
    "High Bandwidth","High Bandwidth",
    "Low Bandwidth","Low Bandwidth",
    "Medium Bandwidth","Medium Bandwidth",
    "The Internet",
    "Data Center A (Uptime)",
    "Data Center B (Uptime)",
    "Redundant Network",
    "Data Center C (Downtime)",
    "Data Center D (High Latency)",
    "Farther Away",
    "Data Center E (Uptime)",
    "Internal Network",
    "Storage Server",
    "Processing Server",
    "The Cloud"
  ];

  // ---------------------------
  // 2) Answer rules
  // ---------------------------
  const ZONES = {
    // Clients: order doesn't matter
    client1: { type:"group", group:"clients" },
    client2: { type:"group", group:"clients" },
    client3: { type:"group", group:"clients" },
    client4: { type:"group", group:"clients" },
    client5: { type:"group", group:"clients" },
    client6: { type:"group", group:"clients" },

    // Bandwidth: specific to each original line
    bw1: { type:"exact", answer:"High Bandwidth" },
    bw2: { type:"exact", answer:"Low Bandwidth" },
    bw3: { type:"exact", answer:"Medium Bandwidth" },
    bw4: { type:"exact", answer:"High Bandwidth" },
    bw5: { type:"exact", answer:"Medium Bandwidth" },
    bw6: { type:"exact", answer:"Low Bandwidth" },

    internet: { type:"exact", answer:"The Internet" },

    // Data Centers:
    // Only Data Center C must be in its specific spot.
    dcC: { type:"exact", answer:"Data Center C (Downtime)" },

    // A/B/D/E can be in any of these four zones (order doesn't matter)
    dcA: { type:"group", group:"datacenters_other" },
    dcB: { type:"group", group:"datacenters_other" },
    dcD: { type:"group", group:"datacenters_other" },
    dcE: { type:"group", group:"datacenters_other" },

    redundant: { type:"exact", answer:"Redundant Network" },
    internal: { type:"exact", answer:"Internal Network" },
    farther: { type:"exact", answer:"Farther Away" },

    storage: { type:"exact", answer:"Storage Server" },
    processing: { type:"exact", answer:"Processing Server" },

    cloud: { type:"exact", answer:"The Cloud" }
  };

  const GROUPS = {
    clients: new Set(["Client 1","Client 2","Client 3","Client 4","Client 5","Client 6"]),
    datacenters_other: new Set([
      "Data Center A (Uptime)",
      "Data Center B (Uptime)",
      "Data Center D (High Latency)",
      "Data Center E (Uptime)"
    ])
  };

  // ---------------------------
  // 3) State
  // ---------------------------
  const state = {
    // zoneId -> wordText
    placements: {},
    // available words in bank
    bankWords: []
  };

  const bankEl = document.getElementById("bank");
  const scoreBox = document.getElementById("scoreBox");
  const submitBtn = document.getElementById("submitBtn");
  const resetBtn  = document.getElementById("resetBtn");
  const outlineBtn= document.getElementById("outlineBtn");
  const zones = Array.from(document.querySelectorAll(".dropzone"));

  function shuffle(arr){
    const a = arr.slice();
    for(let i=a.length-1;i>0;i--){
      const j = Math.floor(Math.random()*(i+1));
      [a[i],a[j]] = [a[j],a[i]];
    }
    return a;
  }

  function clearFeedback(){
    zones.forEach(z=>{
      z.classList.remove("good","bad");
    });
    scoreBox.textContent = "";
  }

  function createWordChip(text){
    const div = document.createElement("div");
    div.className = "word";
    div.textContent = text;
    div.draggable = true;
    div.dataset.word = text;

    div.addEventListener("dragstart", (e)=>{
      div.classList.add("dragging");
      e.dataTransfer.setData("text/plain", text);
    });
    div.addEventListener("dragend", ()=>{
      div.classList.remove("dragging");
    });

    return div;
  }

  function renderBank(){
    bankEl.innerHTML = "";
    state.bankWords.forEach(w=>{
      bankEl.appendChild(createWordChip(w));
    });
  }

  function setZoneText(zoneEl, text){
    zoneEl.innerHTML = "";
    if(!text) return;
    const span = document.createElement("div");
    span.className = "dz-text";
    span.textContent = text;
    zoneEl.appendChild(span);
  }

  function renderZones(){
    zones.forEach(z=>{
      const id = z.dataset.zone;
      const word = state.placements[id];
      z.classList.toggle("filled", !!word);
      setZoneText(z, word || "");
    });
  }

  function init(){
    state.placements = {};
    state.bankWords = shuffle(WORDS);
    clearFeedback();
    renderBank();
    renderZones();
  }

  // ---------------------------
  // 4) Drag & drop behavior
  // ---------------------------
  function removeFromBank(word){
    const idx = state.bankWords.indexOf(word);
    if(idx >= 0) state.bankWords.splice(idx,1);
  }
  function addToBank(word){
    state.bankWords.push(word);
  }
  function isZoneFilled(zoneId){
    return !!state.placements[zoneId];
  }
  function removeFromZone(zoneId){
    const existing = state.placements[zoneId];
    if(existing){
      delete state.placements[zoneId];
      addToBank(existing);
    }
  }

  zones.forEach(zoneEl=>{
    zoneEl.addEventListener("dragover", (e)=>{
      e.preventDefault();
    });

    zoneEl.addEventListener("drop", (e)=>{
      e.preventDefault();
      clearFeedback();

      const zoneId = zoneEl.dataset.zone;
      const word = e.dataTransfer.getData("text/plain");
      if(!word) return;

      // If this zone already has a word, return it to bank first.
      if(isZoneFilled(zoneId)){
        removeFromZone(zoneId);
      }

      // If this word is currently placed in some OTHER zone, remove it from there.
      for(const [zid, w] of Object.entries(state.placements)){
        if(w === word){
          delete state.placements[zid];
        }
      }

      // Remove from bank (if it was in bank)
      removeFromBank(word);

      // Place in zone
      state.placements[zoneId] = word;

      renderBank();
      renderZones();
    });

    // Click a filled zone to return its word to the bank
    zoneEl.addEventListener("click", ()=>{
      clearFeedback();
      const zoneId = zoneEl.dataset.zone;
      if(isZoneFilled(zoneId)){
        removeFromZone(zoneId);
        renderBank();
        renderZones();
      }
    });
  });

  // Allow dropping words back into bank
  bankEl.addEventListener("dragover", (e)=> e.preventDefault());
  bankEl.addEventListener("drop", (e)=>{
    e.preventDefault();
    clearFeedback();
    const word = e.dataTransfer.getData("text/plain");
    if(!word) return;

    // If word is placed somewhere, remove it from that zone
    for(const [zid, w] of Object.entries(state.placements)){
      if(w === word){
        delete state.placements[zid];
      }
    }
    // If it's not already in bank, add it
    if(!state.bankWords.includes(word)){
      addToBank(word);
    }
    renderBank();
    renderZones();
  });

  // ---------------------------
  // 5) Checking / scoring
  // ---------------------------
  function checkAnswers(){
    clearFeedback();

    // Ensure all zones have something to check
    const zoneIds = Object.keys(ZONES);
    const unanswered = zoneIds.filter(zid => !state.placements[zid]);

    let correctCount = 0;
    let total = zoneIds.length;

    // Build group tracking (uniqueness + membership)
    // For groups, we check:
    //  - word is in allowed set
    //  - no duplicates within that group
    const groupSeen = {};
    for(const gid of Object.keys(GROUPS)){
      groupSeen[gid] = new Set();
    }

    zoneIds.forEach(zoneId=>{
      const zoneEl = zones.find(z => z.dataset.zone === zoneId);
      const rule = ZONES[zoneId];
      const placed = state.placements[zoneId];

      let isCorrect = false;

      if(rule.type === "exact"){
        isCorrect = placed === rule.answer;
      } else if(rule.type === "group"){
        const allowed = GROUPS[rule.group];
        if(allowed.has(placed) && !groupSeen[rule.group].has(placed)){
          // tentatively correct, pending others
          isCorrect = true;
          groupSeen[rule.group].add(placed);
        } else {
          isCorrect = false;
        }
      }

      zoneEl.classList.add(isCorrect ? "good" : "bad");
      if(isCorrect) correctCount++;
    });

    const unansweredText = unanswered.length
      ? `Unanswered: ${unanswered.length} (they count as incorrect).`
      : "All blanks filled.";

    scoreBox.innerHTML = `
      <div><b>Score:</b> ${correctCount} / ${total}</div>
      <div class="small">${unansweredText}</div>
      <div class="small">Tip: Click any wrong box to return the word to the bank and try again.</div>
    `;
  }

  // ---------------------------
  // 6) Buttons
  // ---------------------------
  submitBtn.addEventListener("click", checkAnswers);
  resetBtn.addEventListener("click", init);

  let outlinesOn = false;
  outlineBtn.addEventListener("click", ()=>{
    outlinesOn = !outlinesOn;
    zones.forEach(z=> z.classList.toggle("show-outline", outlinesOn));
  });

  init();
</script>
</body>
</html>
